# Reads <experiment_name>_taskinfo.dat files and generates the necessary
# analyze scripts to generate phenotype files.
#
# Output scripts are named thus:
#		analyze-phen-<run_name>-<seed>-<update>.cfg
#
# Analyze scripts will produce files named thus:
#		phenotypes-<run_name>-<seed>-<update>.dat
#
# BLW
# 8-20-09
# 9-15-09
# 7-11-11

import os.path
import os
import sys
from optparse import OptionParser

# Set up parser
# I like to use it just for the easy --help option even if I have no others
usage = """usage: %prog [options] experiment_name

An <experiment_name>_taskinfo.dat file is required.

Output script is named analyze-phen-<experiment_name>.cfg and is placed in the config directory under the current directory.  If the config directory does not exist, the file is placed in the current directory.

When run, these analyze scripts produce files named phenotypes-<experiment_name>-<seed>-<update>.dat which are placed in the <experiment_name>_phenotypes directory."""

parser = OptionParser(usage)

(options, args) = parser.parse_args()

experiment_name = args[0]

analyze_name = "analyze-phen-" + experiment_name + ".cfg"
phenotypes_output_dir = os.path.abspath(experiment_name + "_phenotypes")
taskfile_name = experiment_name + "_taskinfo.dat"
end_of_run = 100000

# Does _taskinfo.dat file exist?
if not os.path.exists(taskfile_name):
	print "Error: " + taskfile_name + " does not exist.  Please run taskstat_generator.py for this experiment."
	sys.exit()

# Check for config directory
if not os.path.exists("config"):
	print "Cannot find config directory; placing " + analyze_name + " in the current directory."
else:
	analyze_name = "config/" + analyze_name

afd = open(analyze_name, "w")

# Write intro
afd.write("# Analyze file autogenerated by phenanalyze_generator.py\n")
afd.write("# For each seed and update with relevant data, unzips and reads the population detail file and produces a list of (task-signature) phenotypes, zipping population file again when finished.\n")
afd.write("\n\n")

# Create phenotypes directory
afd.write("# Create directory to store phenotypes\n")
afd.write("SYSTEM mkdir " + experiment_name + "_phenotypes\n\n")

tfd = open(taskfile_name, "r")

for line in tfd:
	line = line.strip()
	
	if len(line) == 0 or line[0] == "#":
		continue
		
	line = line.split()
	
	seed = int(line[0])
	first_EQU = int(line[1])
	fixed_EQU = int(line[2])
	
	# modify update numbers to the previous divisible-by-50 update,
	# remaining the same if already divisble by 50
	# Since population detail files are only available every 50 updates
	first_EQU -= (first_EQU % 50)
	fixed_EQU -= (fixed_EQU % 50)
	
	updates = [first_EQU, fixed_EQU, end_of_run]
	updates = [x for x in updates if x >= 0]  # screen out -1 "didn't happen"s
	
	data_directory = os.path.abspath(experiment_name + "_" + str(seed) + "/data")
	if not os.path.exists(data_directory):		
		# Help!  We can't find the data directory!
		print "Error:", run_name + "_" + str(seed) + "/data/", "cannot be found.  No analyze instructions will be generated for this seed."
		continue
	
	for update in updates:
		population_filename = data_directory + "/detail-" + str(update) + ".spop"
		phenotypes_filename = phenotypes_output_dir + "/phenotypes-" + experiment_name + "-" + str(seed) + "-" + str(update) + ".dat"
				
		# Tag this with a note: seed, update, which point of interest it is
		afd.write("# Generates phenotypes file for seed " + str(seed) + ", update " + str(update))
		if update == first_EQU:
			afd.write(" (first EQU appearance)\n")
		elif update == fixed_EQU:
			afd.write(" (EQU fixed)\n")
		else:
			afd.write(" (end of run)\n")
		
		# Actual functionality
		afd.write("SYSTEM gunzip " + population_filename + ".gz\n")
		afd.write("\n")
		
		afd.write("LOAD " + population_filename + "\n")
		afd.write("RECALCULATE\n")
		afd.write("PRINT_PHENOTYPES " + phenotypes_filename + "\n\n")		
		
		afd.write("PURGE_BATCH\n")
		afd.write("SYSTEM gzip " + population_filename + "\n\n\n")
		
		print "Generated analyze instructions for seed " + str(seed) + ", update " + str(update)
	
tfd.close()
afd.close()