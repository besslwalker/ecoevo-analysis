# Graphs produced from ecoevo stats
#
#
# WHAT TO RUN:
#   To see boxplot comparisons filtering out non-achieving runs, run:
#   > plot_boxplots(numerical_filter)
#   
#   To see boxplot comparisons without filtering, run:
#   > plot_boxplots(lambda L: L)
#
#   Scatterplot and histograms are available for all combinations of:
#   - entropy types: ENTROPY without filtering out inviable orgs,
#                    V_ENTROPY for filtering out inviable orgs
#   - milestones: FIRST for the initial acquision of EQU, which may be lost
#                 FIXED for the acquision of EQU that fixes
#   - achievement filtering, as in plot_boxplots()
#   Example: to see the plots of first EQU aquisition vs. time in updates,
#            calculating entropy from only viable organisms, filtering out 
#            runs that never achieved EQU, run:
#   > plot_scatterhist(FIRST, V_ENTROPY, numerical_filter)
#
# Written with Python 2.7.1, which is required for some argparse stuff.
# Written with matplotlib 0.99 and 1.01
# Legend stuff requires at least matplotlib-0.98
# BLW 9-3-09
# BLW 7-18-11

import matplotlib as mpl

# Show me the pretty pictures!  Use -X when sshing in.
# mpl.use("TkAgg")

# Use 3rd-party pgf backend (incorporated into matplotlib as of 1.2)
# Code from matplotlib-backend-pgf's README
# mpl.use("module://backend_pgf")
# rc_cmufonts = {
#     "font.family": "serif",
#     "font.serif": ["CMU Serif"],
#     "font.sans-serif": ["CMU Sans Serif"],
#     "font.monospace": [], # fallback to the default LaTeX monospace font
#     }
# mpl.rcParams.update(rc_cmufonts)

import sys
from pylab import *
from matplotlib.ticker import NullFormatter
from matplotlib.font_manager import FontProperties
import numpy as np
from ecoevo_stats import *
from argparse import ArgumentParser


# SET UP ARGUMENTS
parser = ArgumentParser(description = "This script takes the stats generated by ecoevo_stats.py and produces various graphs.")

# Which graph?  
# You must choose only one; if you don't, it graphs the scatterhist.
#
# Because add_mutually_exclusive_group() doesn't accept a title,
# I am using the workaround mentioned at http://bugs.python.org/issue10680
# That is, I create a dummy normal group with the title, and put the 
# mutually exclusive group in that.
#
# This is why I require 2.7.1.
dummy_graph_group = parser.add_argument_group("Choose Your Graph")
graph_group = dummy_graph_group.add_mutually_exclusive_group()
graph_group.add_argument("-b", "--boxplots", action = "store_false", 
                       dest = "graph_scatterhist", help = "graph boxplots")
graph_group.add_argument("-s", "--scatterhist", action = "store_true",
                       dest = "graph_scatterhist", default = True,
                       help = "graph scatterhist (by default)")

# Graph top histogram cumulatively, or not?
parser.add_argument("-c", "--cumulative-time-histogram", action="store_true",
                          default=False, help = "display the histogram of # of populations evolving EQU over time as a cumulative histogram")


# Data settings
data_group = parser.add_argument_group("Choose which Data to Use")
data_group.add_argument("-u", "--unfiltered", action = "store_true", 
                          default = False, help = "include all runs in all statistics, using a value of infinity for any milestone which was not achieved (default: %(default)s)")
data_group.add_argument("-i", "--include-inviable", action = "store_true", 
                          default = False, help = "include inviable genotypes in phenotypic entropy calculation; ignored if graphing boxplots (default %(default)s)")
data_group.add_argument("-1", "--graph-first", action = "store_false",
                           default = False, help = "graph data from first aquisition of EQU in population instead of from the fixation of EQU on the dominant EQU lineage; ignored if graphing boxplots (default: %(default)s, i.e. graph the fixation data)")
                           
# Options for markers on the scatterhist
# If no option is chosen, uses --group_markers
#
# I use the "titles for mutually exclusive groups" workaround as above.
dummy_marker_group = parser.add_argument_group("Choose Scatterhist Markers")
marker_group = dummy_marker_group.add_mutually_exclusive_group()
marker_group.add_argument("-f", "--show-fitness-change", action = "store_const",
                          const = FITNESS, dest = "marker_type", default = "NONE",
                          help = "give fitness loss, gain, and equality different markers; ignored if graphing boxplots or first acquisitions")
marker_group.add_argument("-t", "--show-tradeoffs", action = "store_const",
                          const = TRADEOFF, dest = "marker_type", default = "NONE", 
                          help = "give task loss, task gain, and task equality different markers; ignored if graphing boxplots or first acquisitions")
marker_group.add_argument("-g", "--group-markers", action = "store_const",
                          const = "NONE", dest = "marker_type", default = "NONE",
                          help = "use the same marker for all points from the same experiments, ignoring task tradeoffs and fitness change; ignored if graphing boxplots (default)")
                          
# Name those experiments
parser.add_argument("-e1", "--experiment_1_names", metavar = "NAME", required = True, nargs = "*", help = "The name(s) of the first experiment, i.e. unlimited-base.  One name is typical.")
parser.add_argument("-e2", "--experiment_2_names", metavar = "NAME", required = True, nargs = "*", help = "The name(s) of the second experiment, i.e. limited-base.  One name is typical.")

              
              
# First, let's have some boxplots.  Everything is significant, but what the heck

def sub_boxplot(sp_num, data, sp_title, ticknames):
  sp = subplot(4, 3, sp_num)
  boxplot(data, 1)
  sp.yaxis.grid(True, linestyle = "-", which='major', color='lightgrey',
              alpha=0.5)
  sp.set_axisbelow(True)
  sp.set_title(sp_title)
  xticknames = setp(sp, xticklabels = ticknames)
  

def plot_boxplots(filter_func):
    TICK_LABELS= [exp_1[LABEL], exp_2[LABEL]]
    fig = figure()
    
    # TIME : to first EQU
    sub_boxplot(1, (filter_func(exp_1[FIRST][UPDATES][DATA]), 
                                    filter_func(exp_2[FIRST][UPDATES][DATA])), 
                                 "# updates to first EQU", TICK_LABELS)
    
    # TIME : to fixing EQU
    sub_boxplot(2, (filter_func(exp_1[FIXED][UPDATES][DATA]),
                                    filter_func(exp_2[FIXED][UPDATES][DATA])), 
                                 "# updates to fixing EQU", TICK_LABELS)
                                 
    # TASKS PER ORG: at end of run
    sub_boxplot(3, (exp_1[FINAL][TASKS_PER_ORG][DATA],
                    exp_2[FINAL][TASKS_PER_ORG][DATA]),
                    "# tasks per org at end of run", TICK_LABELS)
        
    # TRADEOFFS : at fixing EQU (in lineage)
    sub_boxplot(5, (filter_func(exp_1[FIXED][TRADEOFF][DATA]),
                                    filter_func(exp_2[FIXED][TRADEOFF][DATA])), 
                                 "task tradeoff at fixing EQU", TICK_LABELS)
                                 
    # FITNESS RATIO: at fixing EQU in lineage, evaluated in unlimited environment
    sub_boxplot(6, (filter_func(exp_1[FIXED][FITNESS][DATA]),
                    filter_func(exp_2[FIXED][FITNESS][DATA])),
                    "fitness ratio at fixing EQU", TICK_LABELS)
    
    # ENTROPY : at first EQU
    sub_boxplot(7, (filter_func(exp_1[FIRST][ENTROPY][DATA]), 
                                    filter_func(exp_2[FIRST][ENTROPY][DATA])), 
                                 "entropy at first EQU", TICK_LABELS)
    
    # ENTROPY : at fixing EQU
    sub_boxplot(8, (filter_func(exp_1[FIXED][ENTROPY][DATA]),
                                    filter_func(exp_2[FIXED][ENTROPY][DATA])), 
                                 "entropy at fixing EQU", TICK_LABELS)
    
    # ENTROPY : at end of run (filtering does nothing here)
    sub_boxplot(9, (filter_func(exp_1[FINAL][ENTROPY][DATA]), 
                                    filter_func(exp_2[FINAL][ENTROPY][DATA])),
                                 "entropy at end of run", TICK_LABELS)
    
    # V_ENTROPY : at first EQU
    sub_boxplot(10, (filter_func(exp_1[FIRST][V_ENTROPY][DATA]), 
                                     filter_func(exp_2[FIRST][V_ENTROPY][DATA])), 
                                    "v_entropy at first EQU", TICK_LABELS)
    
    # V_ENTROPY : at fixing EQU
    sub_boxplot(11, (filter_func(exp_1[FIXED][V_ENTROPY][DATA]), 
                                     filter_func(exp_2[FIXED][V_ENTROPY][DATA])), 
                                    "v_entropy at fixing EQU", TICK_LABELS)
    
    # V_ENTROPY: at end of run (filtering does nothing here)
    sub_boxplot(12, (filter_func(exp_1[FINAL][V_ENTROPY][DATA]), 
                                     filter_func(exp_2[FINAL][V_ENTROPY][DATA])), 
                                    "v_entropy at end of run", TICK_LABELS)
                                    
    show()


# Split a dataset into three based on task tradeoffs or fitness ratio
def split_data(dict, entropy_type, filter_func, split_type):
  x_gain = []
  y_gain = []
  x_same = []
  y_same = []
  x_loss = []
  y_loss = []
  
  if split_type == TRADEOFF:
    breakeven = 0
  elif split_type == FITNESS:
    breakeven = 1.0
    
  for i in range(len(dict[FIXED][UPDATES][DATA])):
    if dict[FIXED][split_type][DATA][i] == breakeven:
      x_same.append(dict[FIXED][UPDATES][DATA][i])
      y_same.append(dict[FIXED][entropy_type][DATA][i])
    elif dict[FIXED][split_type][DATA][i] > breakeven:
      x_gain.append(dict[FIXED][UPDATES][DATA][i])
      y_gain.append(dict[FIXED][entropy_type][DATA][i])
    else:
      x_loss.append(dict[FIXED][UPDATES][DATA][i])
      y_loss.append(dict[FIXED][entropy_type][DATA][i])
      
  return (filter_func(x_gain), filter_func(y_gain)), \
         (filter_func(x_same), filter_func(y_same)), \
         (filter_func(x_loss), filter_func(y_loss))
         

# Now let's do a neat combination of histograms and scatterplot
# Inspired by and with code largely based on matplotlib's
# scatter_hist example, which can be found at
# http://matplotlib.sourceforge.net/examples/pylab_examples/scatter_hist.html
# 
# X-axis is TIME in # updates
# Y-axis is ENTROPY
#
# entropy_type should be one of {ENTROPY, V_ENTROPY}
# milestone should be one of {FIRST, FIXED}
def plot_scatterhist(milestone, entropy_type, filter_func, marker_type, cumulative_time_histogram):
    x_exp_1 = filter_func(exp_1[milestone][UPDATES][DATA])
    y_exp_1 = filter_func(exp_1[milestone][entropy_type][DATA])
    
    x_exp_2 = filter_func(exp_2[milestone][UPDATES][DATA])
    y_exp_2 = filter_func(exp_2[milestone][entropy_type][DATA])
    
    # no labels
    nullfmt = NullFormatter()
    
    # place the axes and rectangles
    left, width = .1, .61
    bottom, height = .1, .61
    bottom_h = left_h = left + width + .03
    
    rect_scatter = [left, bottom, width, height]
    rect_histx = [left, bottom_h, width, .21]
    rect_histy = [left_h, bottom, .21, height]
    
    
    # start with rectangular figure and place axes on it
    figure(1, figsize = (6.6, 6.3))
    
    axScatter = axes(rect_scatter)
    axHistX = axes(rect_histx)
    axHistY = axes(rect_histy)
    
    # place A, B, C subgraph labels
    axScatter.text(1000, 1.35, "A")
    axHistX.text(1000, 12.5, "B")
    axHistY.text(1, 1.35, "C")
    
    # no labels for histograms
#   axHistX.xaxis.set_major_formatter(nullfmt)
#   axHistY.yaxis.set_major_formatter(nullfmt)
    
    markersize = 50
    
    num_exp_1_types = 0
    num_exp_2_types = 0
    
#   print marker_type, marker_type == "FITNESS", marker_type in [FITNESS, TRADEOFF], [FITNESS, TRADEOFF], milestone
    
    # We have the option to have different markers to show the fitness ratio 
    # or tradeoff situations:
    if (marker_type in [FITNESS, TRADEOFF]) and milestone == FIXED:
        
        if marker_type == FITNESS:
            # split each dataset into gained, lost, and stayed the same
            exp_1_gain, exp_1_same, exp_1_loss = split_data(exp_1, entropy_type, filter_func, FITNESS)
            
            exp_2_gain, exp_2_same, exp_2_loss = split_data(exp_2, entropy_type, filter_func, FITNESS)
            
            label_text = "fitness"
        
        elif marker_type == TRADEOFF:
            # split each dataset into gained, lost, and stayed the same
            exp_1_gain, exp_1_same, exp_1_loss = split_data(exp_1, entropy_type, filter_func, TRADEOFF)
            
            exp_2_gain, exp_2_same, exp_2_loss = split_data(exp_2, entropy_type, filter_func, TRADEOFF)
            
            label_text = "task"
        
        # plot split scatterplot
        # with allowance for not being allowed to plot empty lists
        if len(exp_1_gain[0]) > 0:
            axScatter.scatter(exp_1_gain[0], exp_1_gain[1], c = "b", marker = "+", 
                                                s = markersize, edgecolor = "b", label = label_text + " gain (" + str(len(exp_1_gain[0])) + ")")
            num_exp_1_types += 1
        if len(exp_1_same[0]) > 0:
            axScatter.scatter(exp_1_same[0], exp_1_same[1], c = "b", marker = "s", 
                                                s = markersize, edgecolor = "b", label = "no change (" + str(len(exp_1_same[0])) + ")")
            num_exp_1_types += 1
        if len(exp_1_loss[0]) > 0:
            axScatter.scatter(exp_1_loss[0], exp_1_loss[1], c = "b", marker = "v", 
                                                s = markersize, edgecolor = "b", label = label_text + " loss (" + str(len(exp_1_loss[0])) + ")")
            num_exp_1_types += 1
        
        if len(exp_2_gain[0]) > 0:
            axScatter.scatter(exp_2_gain[0], exp_2_gain[1], c = "r", marker = "+", 
                                                s = markersize, edgecolor = "r", label = label_text + " gain (" + str(len(exp_2_gain[0])) + ")")
            num_exp_2_types += 1
        if len(exp_2_same[0]) > 0:
            axScatter.scatter(exp_2_same[0], exp_2_same[1], c = "r", marker = "s", 
                                                s = markersize, edgecolor = "r", label = "no change (" + str(len(exp_2_same[0])) + ")")
            num_exp_2_types += 1
        if len(exp_2_loss[0]) > 0:
            axScatter.scatter(exp_2_loss[0], exp_2_loss[1], c = "r", marker = "v", 
                                                s = markersize, edgecolor = "r", label = label_text + " loss (" + str(len(exp_2_loss[0])) + ")")  
            num_exp_2_types += 1
    
    
    # If not showing split-up markers, plot the simple scatterplot
    else:
        axScatter.scatter(x_exp_1, y_exp_1, c = "b", marker = "s", s = markersize, edgecolor = "b", label = exp_1[LABEL])
        axScatter.scatter(x_exp_2, y_exp_2, c = "r", marker = "s", s = markersize, edgecolor = "r", label = exp_2[LABEL])
          
    # find nice bin sizes and limits
    xmax = 100000
    xmin = 0
    ymax = numerical_max(y_exp_1 + y_exp_2)
    ymax += ymax * .05
    ymin = 0
    
    axScatter.set_xlim((xmin, xmax))
    axScatter.set_ylim((ymin, ymax))
    
    numbins = double(25)
    xbinwidth = (xmax - xmin) / numbins
    ybinwidth = (ymax - ymin) / numbins
    
    xbins = np.arange(xmin, xmax + xbinwidth, xbinwidth)
    ybins = np.arange(ymin, ymax + ybinwidth, ybinwidth)
    
    # plot the histograms
    xn, xbins, xpatches = axHistX.hist([x_exp_1, x_exp_2], bins = xbins, histtype = "bar", cumulative = cumulative_time_histogram)
    setp(xpatches[1], 'facecolor', 'r')
    
    yn, ybins, ypatches = axHistY.hist([y_exp_1, y_exp_2], bins = ybins, histtype = "bar", orientation = "horizontal")
    setp(ypatches[1], 'facecolor', 'r')
    
    axHistX.set_xlim( axScatter.get_xlim() )
    axHistY.set_ylim( axScatter.get_ylim() )
    
    # let's get some lines on these things
    axHistX.yaxis.grid(True, linestyle = "-", which = "major", color = "lightgrey", alpha = ".5")
    axHistX.set_axisbelow(True)
    
    axHistY.xaxis.grid(True, linestyle = "-", which = "major", color = "lightgrey", alpha = ".5")
    axHistY.set_axisbelow(True)
        
    # some titles might be nice, too, and let's adjust the tick labels
    axScatter.set_xlabel("Time (Updates $\\times{10^{4}}$)")
    axScatter.set_xticklabels(("0", "2", "4", "6", "8", "10"))
        
    if entropy_type == ENTROPY:
        axScatter.set_ylabel("Shannon Diversity (Phenotypes)")
    elif entropy_type == V_ENTROPY:
        axScatter.set_ylabel("Shannon Diversity (Phenotypes, Viable Only)")
    else:
        axScatter.set_ylabel("Unrecognized Entropy Type")
        
    axHistX.set_ylabel("\# Populations")
#   axHistX.set_xticklabels(("0", "2", "4", "6", "8", "10"))
    axHistY.set_xlabel("\# Populations")
    
    # get rid of the X histogram's xticklabels, and the Y's yticklabels
    axHistX.set_xticklabels([], visible = "False")
    axHistY.set_yticklabels([], visible = "False")
    
    if milestone == FIRST:
        suptitle("Shannon Diversity vs. Time to Aquisition of EQU")
    elif milestone == FIXED:
        suptitle("Shannon Diversity vs. Time to Fixing EQU")
    else:
        suptitle("Shannon Diversity vs. Time at Unknown Milestone")
        
    # Legend
    # Normal legends are more straightforward, but because I want the label for
    # the scatterhist to be outside it, I have to get fancy.
    # Normally you'd just call axScatter.legend()
    #
    # Note: if we use circle markers, get_legend_handles_labels doesn't see them.
    font = FontProperties(size = 10)  
    handles, labels = axScatter.get_legend_handles_labels()
    
    # For fancy markers, we want a fancy legend
    if marker_type in [FITNESS, TRADEOFF]:
        exp_1_proxy_handle = Rectangle((0, 0), 1, 1, fc="w", ec="w")
        exp_2_proxy_handle = Rectangle((0, 0), 1, 1, fc="w", ec="w")
            
        # Dear Future Bess,
        # Having both handles and both labels using num_exp_1_types is NOT
        # a typo.  Look more closely at the list slicers.
        final_handles = [exp_1_proxy_handle] + handles[:num_exp_1_types] + [exp_2_proxy_handle] + handles[num_exp_1_types:]
        final_labels = [exp_1[LABEL]] + labels[:num_exp_1_types] + [exp_2[LABEL]] + labels[num_exp_1_types:]
    else:
        final_handles = handles
        final_labels = labels
    
    #figlegend(final_handles, final_labels, scatterpoints = 1, bbox_to_anchor = (left_h, bottom_h, .2, .2), loc = "center", mode = "expand", borderaxespad = 0., prop = font)      
    figlegend(final_handles, final_labels, scatterpoints = 1, bbox_to_anchor = (left_h, bottom_h, .2, .2), loc = "center", borderaxespad = 0., prop = font)      
            
    #show()

#   from matplotlib2tikz import save as tikz_save
#   tikz_save('scatterhist.tikz', figureheight='\\figureheightscatterhist', figurewidth='\\figurewidthscatterhist')

    print "Saving figure..."
#    savefig("scatterhist.pgf")
    savefig("scatterhist.pdf")


# Line graph of # tasks per individual and per population over time
def plot_tasksovertime():
    pass


if __name__ == "__main__":
    args = parser.parse_args()
    args = vars(args)  # transform Namespace into dictionary
    exp_1_names = args["experiment_1_names"]
    exp_2_names = args["experiment_2_names"]
    
    # Set up ecoevo_stats stuff
    exp_1, exp_2, label_width = do_setup(exp_1_names, exp_2_names)
    
    if args["unfiltered"]:
        filter_func = lambda x:x
    else:
        filter_func = numerical_filter
        
    do_reports(filter_func, exp_1, exp_2, label_width)
    
    if not args["graph_scatterhist"]:  # then graph boxplots
        plot_boxplots(filter_func)
            
    else:
        if args["graph_first"]:
            milestone = FIRST
        else:
            milestone = FIXED
        
        if args["include_inviable"]:
            entropy_type = ENTROPY
        else:
            entropy_type = V_ENTROPY
            
        
        plot_scatterhist(milestone, entropy_type, filter_func, args["marker_type"], args["cumulative_time_histogram"])
    
    